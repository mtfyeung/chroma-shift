<html>
<head>
    <meta name="viewport"
      content="
        height = device-height,
        width = device-width,
        initial-scale = 1.0,
        minimum-scale = 1.0,
        maximum-scale = 1.0,
        user-scalable = no" />
	<script id="vertexShader" type="x-shader/x-vertex">
    precision highp float;

    varying vec2 vUv;

    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
    </script>

	<script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D texture1;
    uniform float multiplier;

    varying vec2 vUv;

    void main() {
        vec4 pxl = texture2D(texture1, vUv);
        
        vec3 rgb = pxl.xyz;
        
        //** do color shifts here..
        
        float red = rgb[0];
        float green = rgb[1];
        
        float diff = multiplier*(red - green);

        rgb[0] += diff;
        rgb[1] -= diff;
        
        //**
    
        pxl.xyz = rgb;
        gl_FragColor = pxl;
    }
    </script>
  
    <script src="three.min.js"></script>
    <script src="dat.gui.min.js"></script>

    <script>
    function init_video()
    {
        var video = document.createElement('video');
        video.autoplay = true;
        video.loop = true;
        video.mute = true;
             
        function src_callback(sourceInfos)
        {
            var back_cam_id;

            for (var i = sourceInfos.length - 1; i >= 0; --i) {
                var sourceInfo = sourceInfos[i];
                if (sourceInfo.kind === 'video' && sourceInfo.facing === 'environment')
                {
                    back_cam_id = sourceInfo.id;
                    break;
                }
            }

            if (back_cam_id === undefined)
            {
                return;
            }

            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

            navigator.getUserMedia({video: {
                mandatory: {
                            maxWidth: window.innerWidth,
                            maxHeight: window.innerHeight,
                            minWidth: window.innerWidth,
                            minHeight: window.innerHeight
                            },
                optional: [{sourceId: back_cam_id}]
            }}, function(stream){
                video.src    = window.URL.createObjectURL(stream);
                //video.play();
            }, function(error){
                console.log("Failed to get a stream due to", error);
            });
        }
        
        if (typeof MediaStreamTrack === 'undefined')
        {
            // noop
        }
        else
        {
            MediaStreamTrack.getSources(src_callback);
        }

        return video;
    }

    function init_gui()
    {
        function ControlState()
        {
            this.multiplier = 1.0;
            //this.video_source = '';
        }      

        controls = new ControlState();
        gui = new dat.GUI();
        
        gui.add(controls, 'multiplier', 0, 5);

        return controls;
    }
       
    function init_renderer()
    {
        var renderer = new THREE.WebGLRenderer();
        document.body.appendChild(renderer.domElement);

        return renderer;
    }

    function get_cam_pos(fov_deg)
    {
        //http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene
        // in otherwords, use definition of tan()
        // tan(fov) = opp/adj = h / d
        // (but fov and h both need to be 1/2)

        var fov_rad = fov_deg * Math.PI / 180;

        var h = Math.max(window.innerWidth, window.innerHeight) / 2;

        return h / Math.tan(fov_rad/2);
    }
        
    function init()
    {
        var renderer = init_renderer();
        var video = init_video();
        var controls = init_gui();

        // Initialize Camera
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 99999);

        camera.position.z = get_cam_pos(45);

        // Update video source
        var vtexture = new THREE.Texture(video);

        // Initialize Shaders
        var material = new THREE.ShaderMaterial({
            uniforms: {
                texture1: { type: "t", value: vtexture },
                multiplier : { type: "f", value: 1.0 }},
            vertexShader: document.getElementById('vertexShader').innerHTML,
            fragmentShader: document.getElementById('fragmentShader').innerHTML
        });

        //var plane = new THREE.PlaneGeometry(video.videoWidth, video.videoHeight);
        var plane = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
        var mesh = new THREE.Mesh( plane, material );

        // Initialize scene
        var scene = new THREE.Scene();
        scene.add( mesh );

        return function()
        { 
            requestAnimationFrame( arguments.callee );
            
            if (video.readyState === video.HAVE_ENOUGH_DATA)
            {
                vtexture.needsUpdate = true;
            }
            
            material.uniforms.multiplier.value = controls.multiplier;

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.render( scene, camera );
        };
    }
        
	document.addEventListener("DOMContentLoaded", function(event){
        var animate = init();        
        animate();
    });
    </script>
</head>
<body style="margin:0"></body>
</html>